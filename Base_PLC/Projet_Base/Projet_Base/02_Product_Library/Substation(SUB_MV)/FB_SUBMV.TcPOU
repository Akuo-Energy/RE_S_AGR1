<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.14">
  <POU Name="FB_SUBMV" Id="{59a5aef1-2cc0-4e7d-8dad-c3043741aa94}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SUBMV EXTENDS FB_SUBMV_Base
//////////////////
// MV Substation
//////////////////

VAR_INPUT PERSISTENT
	// Parameters of the Object (instance specific)  
		ParamTempoPoste						: TIME := T#1S; 		(* (s) Temps entre fermeture depart de chaque poste*)
		ParamTempoUnknowFault				: TIME := T#15S;		(* (s) Temps max pour que la MainMVCB reste ouverte avec Aucun défaut et une autorisation de couplage ==> aboutit a une perte d'autorisation*)
		ParamTempoSepamCloseAfterGte		: TIME := T#15S; 		(* (s) Param renseigné dans le Code du sepam + 10 ms *)
		ParamAutoCloseMainMVCBEnabled		: BOOL := FALSE; 		(* (NA) Enable Automatic closing of the HV coupling Cell without Couplig Authorizatioon  *)
		Param_MainMVCB_GTE    				: TIME := T#2M;  		(* (min) Delays MainMVCB cell closure command. If a GTE fault occurs within this period, the delay is reset to prevent unsafe MainMVCB cell manipulation. *)    	
	    ParamAlimAuxGTE						: TIME := T#3m;    
END_VAR

VAR_INPUT 
	MesDataExd								: SUBMV_Exd;  			// (NA) [P,H,B] MCA SUB_MV specific Data structure 
	// I/O Inputs 
		IN_MesCouplerState_IO				: UINT ; 				// Coupler State IO
		                                                        	                                                           									
		IN_MesStopMVCC						: BOOL ; 				// Stop the sequence for closing or opening 
		{attribute 'OPC.UA.DA' := '1'} 
		IN_CmdNoFeeding						: BOOL ; 				// Order to disconnect generators to the grid
		{attribute 'OPC.UA.DA' := '1'}                                  
		IN_CmdFeeding						: BOOL ; 				// Order to connect generators to the grid
		IN_CmdOpenMainMVCB					: BOOL ;
		IN_CmdCloseMainMVCB					: BOOL ;
		
		IN_CmdOpenFeederMVCB				: ARRAY[1..CstNbFeederMVCB_G] OF BOOL ;	
		IN_CmdCloseFeederMVCB				: ARRAY[1..CstNbFeederMVCB_G] OF BOOL ;		
		
	// EQUIPMENTS
		A1_GRID								: FB_GRID_Enedis; 
//		A1_SOFREL							: FB_GRID_SOFREL; For Corsica plants : FB to be added
		A1_MainMVCB							: FB_CB_MainMVCB;
		A1_SecondMainMVCB					: FB_CB_MainMVCB;		
		AX_FeederMVCB						: ARRAY[1..CstNbFeederMVCB_G] OF FB_CB_FeederMVCB ; 	// 1: INV , 2 : BESS
		AX_GridMVCB							: ARRAY[1..CstNbGridMVCB_G] OF FB_CB_GridMVCB ;
		A1_MeasureMVCB						: FB_CB_MeasureMVCB;				(* Measure Cell                                        	*)
		A1_AuxMVCB							: FB_CB_AuxMVCB;					(* Auxiliary cell                                      	*)
		A1_CB_24V							: FB_TOR_Standard;					(* Série Disjoncteur 24V                               	*)
		A1_CB_48V							: FB_TOR_Standard;					(* Série Disjoncteur 48V                               	*)
		A1_CB_230V							: FB_TOR_Standard;					(* Série Disjoncteur 230V                              	*)
		A1_MainCB_LV						: FB_TOR_Standard ;         		(* Alimentation auxuliaire normale                     	*)
		//A1_DS_transfo							: FB_TOR_Ds ;					(* (NA)TOR Door Sensor object instance Filter room     	*)
		A1_DS_MV							: FB_TOR_Ds ;						(* (NA)TOR Door Sensor object instance Filter room     	*)
		A1_DS_LV							: FB_TOR_Ds ;						(* (NA)TOR Door Sensor object instance Filter room     	*)

		A1_ES_Ext							: FB_TOR_Es ;						(* Emergency stop PDL                                  	*)

		A1_SD_MV							: FB_TOR_Sd;						(* Synthèse alarmes incendie                           	*)
		A1_ProtectRelay						: FB_ProtectRelay_SepamS48; 		(* ID:= 150, 19200,8N1,Sans parité                     	*)
		A1_PM								: FB_PM_Digiware;                   (* Power Meter GRID 									*)
		A1_PM_BESS							: FB_PM_Janitza;		            (* Power Meter BESS 									*)
		A1_PM_SPP							: FB_PM_Janitza;			        (* Power Meter SPP 										*)

		A1_PM_Aux							: FB_PM_Janitza;					(* ID = 50, 19200, 8N1, Sans parité						*)
		A1_UPS_48v							: FB_UPS_ENERIS;
		A1_UPS_24v							: FB_UPS_ENERIS;
				
		A1_Transfo_Aux						: FB_Transfo_MV;

	//Other
		OUT_HVcellsMoving					: BOOL;
		A1_Router_ADSL						: FB_Router;
		A1_Router_4G						: FB_Router;
	
		A1_Switch_1							: FB_Router;
		A1_Switch_2							: FB_Router;
		A1_IPC 								: FB_IPC;
		A1_IPC_EMS 							: FB_IPC;	
		
END_VAR

VAR_OUTPUT
			OUT_ESS_CouplingSequence				: BOOL := FALSE;
			OUT_PTR_CouplingSequence				: BOOL := FALSE;
END_VAR

VAR


	//M_ALARMMANAGEMENT VARIABLES//	
	 	R_TRIG_Event						: ARRAY[1..17] OF R_TRIG ;  
		MesComErrorEthercat	 				: BOOL;														//(NA) Communication Error with Ethercat coupler 
		TOF_Ethercat					 	: TOF ;	
		
		AX_AlarmWords						: ARRAY[1..45] OF ST_ValuesAlarms;
		AX_AlarmWords_Null					: ARRAY[1..45] OF ST_ValuesAlarms;
		NumAlarmsActive						: UINT;
	
	//M_STATEMANAGER  VARIABLES//   

	//M_Feeding
		TOF_End_GTE							: TOF;	           
                         	
	//M_CONNECTDISCONNECT VARIABLES//
		
        HVcellsMoving						: BOOL;														// Etat indiquant qu'une sequence est en cours sur les cellules. 
        SR_CloseMainMVCBManual				: SR ;     
        SR_CloseManual_FeederMVCB			: ARRAY[1..CstNbFeederMVCB_G] OF  SR;					   // Manage force manual opening 
        Protect_GTE_LONG					: BOOL; // Long GTE fault, PP stop for 2m and lost of autorisation 
		CmdCloseMainMVCB_EndGTELong			: BOOL;
		CalFeederManualCmd					: BOOL;		// One open or closed command received form OPC UA for at least one of the feeder .       
		CmdCloseMainMBCVAfterDisconnect		: BOOL;
		CloseMainMVCBAfterDisconnect		: BOOL;
		
		R_TRIG_Feeding						: R_TRIG;    
		F_TRIGFeed							: F_TRIG;
		RSFeed								: RS;    	
		RSNoFeed							: RS;
		R_TRIG_NoFeeding					: R_TRIG;
		TON_ComutDistant					: TON;
	//M_CONNECTDISCONNECT VARIABLES//
             
		F_TRIG_GTELong						: F_TRIG;
		TP_GTELong							: TP ; 
		TON_GteIsLong						: TON;
		TON_GteLongHVMoving					: TON;
		FTRIG_ProtectGTELong				: F_TRIG ; 
		RTRIG_ProtectEndEmergencyDisc		: R_TRIG ; 
		RTRIG_ProtectEndDisc				: R_TRIG ; 
		RTRIG_LimitationSofrel				: R_TRIG ;
		FTRIG_CloseMainMVCB					: F_TRIG;
    	                                    
		TPCloseMainMVCB_EndGTELong			: TP;   
		TPWaitToCloseMainMVCB				: TP; 
		TPCloseMainMVCBAfterDisconnect		: TP;        

	// Unknown fault 
		UnknownFault						: BOOL;         // MainMVCB est reste ouverte avec Aucun défaut et une autorisation de couplage ==> aboutit a une perte d'autorisation    
		RTrigEndGte							: R_TRIG;       //
		TPSepamCloseAfterGte				: TP;  			// 
		
		FB_UnknownFault 					: FB_UnknownEvent ; 			

	//M_Decouplage //               	
		CompletedNoFeed						: BYTE;   			// bit 0: terminé sans Erreur, bit 1: terminé avec alarms, bit 2: terminé avec warning
		CompletedFeed						: BYTE;   			// bit 0: terminé sans Erreur, bit 1: terminé avec alarms, bit 2: terminé avec warning
		CompletedFeedAlarm					: BYTE;  			// bit 0: terminé sans Erreur, bit 1: terminé avec alarms, bit 2: terminé avec warning
		CompletedNoFeedAlarm				: BYTE;
		TON_FeedMainMVCB					: TON;
		TON_NoFeedTR						: TON;
		TON_NoFeedMainMVCB					: TON;
		TP_UnknownFault						: TP;
		TP_Feed_TR_Open						: TP;
		TON_FeedTR							: TON;
		TON_FeedStep						: ARRAY[1..CstNbFeederMVCB_G+1] OF TON;
		TON_Reclose							: TON;

	//M_EVALUATE VARIABLES//        	
   
		R_TRIG_Centraledecouplee			: R_TRIG;			// detect centrale decouplée

END_VAR			
 ]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="M_AlarmManagement" Id="{590daf15-4ee8-4557-a67e-491d86ff18cc}">
      <Declaration><![CDATA[METHOD M_AlarmManagement
//////////////////
// Generates object alarms and manages resets. 
//////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 
	FB_AlarmCodeManager			: FB_AlarmCodeManager ; 

	MesAlarmSynthesischild			: BOOL;
	MesWarningSynthesischild			: BOOL;
	
	GG: INT ; 
	LL: INT;
	ID_Journal: INT;
	WordTest: WORD;
	NbAlarmsToParse : UINT := 1; // number of alarms to parse (if AlarmCode + WarningCode + EventCode = 3)
	InitialNumberOfAlarms : UINT := 12; // ID of the first alarms of the first structure to parse, to be retrieved in FUN_Alarms.M_AlarmManager
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
TOUS LES FB_TOR_BASE DOIVENT ETRE MAPPES DANS LE M_ALARMMANAGEEMNT DU PRODUIT AUQUEL ILS APPARTIENNENT. LEUR PROPRE ALARMCODE NE SERONT PAS MAPPES PAR LE CONFIGURATOR
*)
	//Com
	//COMMUNCATION //	
	TOF_Ethercat(IN:= NOT (SHR(SHL(UINT_TO_BYTE(IN_MesCouplerState_IO),4),4)=8),PT:=ParamTempoComAlarm)  ; 	// IN_MesCouplerState_IO à mapper dans IO
	MesComErrorEthercat 	:= TOF_Ethercat.Q  ; 			// Not OP State  

// ALARM CODE //

// Attention une alarm doit être mise en commentaire de la manière suivante (* *), l'utilisation du // pose pb sur Bazefield 

	FB_AlarmCodeManager(
		bAlarm1			:= FALSE,
		bAlarm2			:= MesComErrorEthercat ,					// Ethercat Communication Error 								#COM
		bAlarm3			:= FALSE,
		bAlarm4			:= FALSE,
		bAlarm5			:= CompletedFeedAlarm.1,					// Not possible to closed MainMVCB during coupling sequence
		bAlarm6			:= IN_MesStopMVCC, 							// PMS in error : Open all MV Switchgears 
		bAlarm7			:= CompletedFeedAlarm.2, 					// At least one FeederMVCB did not close 
		bAlarm8			:= FALSE,
		bAlarm9			:= FALSE,
		bAlarm10		:= FALSE ,									//  
		bAlarm11		:= CompletedNoFeedAlarm.1,					// MainMVCB stayed closed during disconnect sequence
		bAlarm12		:= FALSE,
		bAlarm13		:= FALSE,
		bAlarm14		:= NOT MesDataExd.MesData.MesState.1 ,			// Substation is disconnected
		bAlarm15		:= FALSE , 				
		wAlarmCode		=>MesDataExd.MesData.MesAlarmCode);     
                                          	
          	
                                                              	
// WARNING CODE //                                              	
	FB_AlarmCodeManager(                                        	
 		bAlarm1			:= FALSE,
		bAlarm2			:= FALSE,
		bAlarm3			:= FALSE,
		bAlarm4			:= MesDataExd.MesData.MesOpened_ALOFeederMVCB,// At least one HV cell is opened      		
		bAlarm5			:= FALSE,
		bAlarm6			:= FALSE, 									//       			   
		bAlarm7			:= CompletedNoFeedAlarm.2,					// Generators did not stop during disconnect sequence
		bAlarm8			:= FALSE,
		bAlarm9			:= FALSE,
		bAlarm10		:= FALSE,
		bAlarm11		:= FALSE,
		bAlarm12		:= FALSE,									// 
		bAlarm13		:= FALSE,         							//           
		bAlarm14		:= FALSE,              						//       			
		bAlarm15		:= FALSE,					
		wAlarmCode		=>MesDataExd.MesData.MesWarningCode);  		

// EVENT CODE //
	FB_AlarmCodeManager(
		bAlarm1			:= R_TRIG_Event[1].Q,						// 
		bAlarm2			:= R_TRIG_Event[2].Q,     					// 
		bAlarm3			:= R_TRIG_Event[3].Q, 						// Connect command     
		bAlarm4			:= R_TRIG_Event[4].Q, 						// Disconnect Command
		bAlarm5			:= R_TRIG_Event[5].Q, 						// Reset Command  	       
		bAlarm6			:= R_TRIG_Event[6].Q,						// Coupling sequence has been launched   
		bAlarm7			:= R_TRIG_Event[7].Q, 						// Decoupling sequence has been launched  
		bAlarm8			:= R_TRIG_Event[8].Q, 						// Close MainMVCB order
		bAlarm9			:= R_TRIG_Event[9].Q, 						// Close FeederMVCB.1 order
		bAlarm10		:= R_TRIG_Event[10].Q,                      // Close FeederMVCB.2 order
		bAlarm11		:= R_TRIG_Event[11].Q,                      // Open MainMVCB order
		bAlarm12		:= R_TRIG_Event[12].Q,                      // Open FeederMVCB.1 order
		bAlarm13		:= R_TRIG_Event[13].Q,                      // Open FeederMVCB.2 order
		bAlarm14		:= R_TRIG_Event[14].Q,                      // Grid MVCB is closed 
		bAlarm15		:= R_TRIG_Event[15].Q OR R_TRIG_Event[16].Q,// ADSL OR 4G restarts 
		wAlarmCode		=>MesDataExd.MesData.MesEventCode);   

		
	FB_AlarmCodeManager(
		bAlarm1			:= FALSE ,
		bAlarm2			:= FALSE ,    
		bAlarm3			:= FALSE , 									//
		bAlarm4			:= FALSE , 									//
		bAlarm5			:= FALSE , 									//
		bAlarm6			:= FALSE , 									//
		bAlarm7			:= FALSE , 									//
		bAlarm8			:= FALSE , 									//
		bAlarm9			:= FALSE , 									//
		bAlarm10		:= FALSE ,                               	//
		bAlarm11		:= FALSE ,                               	//
		bAlarm12		:= FALSE ,                               	//
		bAlarm13		:= FALSE ,                               	//
		bAlarm14		:= FALSE ,                               	//
		bAlarm15		:= FALSE ,                               	//
		wAlarmCode		=>MesDataExd.MesData.MesEventCode2);  		
		
R_TRIG_Event[1](CLK	:=FALSE) ; 		
R_TRIG_Event[2](CLK	:=FALSE) ;			 	
R_TRIG_Event[3](CLK	:=IN_CmdConnect    ) ; 
R_TRIG_Event[4](CLK	:=IN_CmdDisconnect ) ;  
R_TRIG_Event[5](CLK	:=IN_CmdReset_L    ) ;  
R_TRIG_Event[6](CLK	:=IN_CmdFeeding	   ) ;  
R_TRIG_Event[7](CLK	:=IN_CmdNoFeeding  ) ;  
R_TRIG_Event[8](CLK	:=IN_CmdCloseMainMVCB   ) ;  
R_TRIG_Event[9](CLK	:=IN_CmdCloseFeederMVCB[1]) ;  
R_TRIG_Event[10](CLK:= IN_CmdCloseFeederMVCB[2]) ; 
R_TRIG_Event[11](CLK:= IN_CmdOpenMainMVCB ) ; 
R_TRIG_Event[12](CLK:= IN_CmdOpenFeederMVCB[1]) ; 
R_TRIG_Event[13](CLK:= IN_CmdOpenFeederMVCB[2]) ;	
R_TRIG_Event[14](CLK:= FALSE);	
R_TRIG_Event[15](CLK:= FALSE);	
R_TRIG_Event[15](CLK:= A1_Router_ADSL.IN_CmdRestart) ;	
R_TRIG_Event[16](CLK:= A1_Router_4G.IN_CmdRestart);
R_TRIG_Event[17](CLK:= A1_IPC.IN_CmdRestart);

// CALCUL DES ALARMCODES //
NumAlarmsActive := 0;
AX_AlarmWords := AX_AlarmWords_Null;
FOR GG := 1 TO NbAlarmsToParse DO	// Loop over alarm , warning and event , system stop operation . ..  
	FOR LL := 1 TO 15 DO
		ID_Journal := InitialNumberOfAlarms + (1 - 1) + (GG - 1)*1;
		
		WordTest := ROR(FUN_Alarms.AX_RecupWord[ID_Journal],LL);
		IF WordTest.0 AND NumAlarmsActive<60 THEN
			NumAlarmsActive := NumAlarmsActive + 1;
			AX_AlarmWords[NumAlarmsActive].Message := FUN_Alarms.AX_Journal[ID_Journal][LL].Message;
		//ELSE
		//	AX_AlarmWords[NumAlarmsActive+1].Message := '';
		END_IF
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ConnectDisconnect" Id="{8018928e-3bf0-4f46-8330-f1d66d9e7f0b}">
      <Declaration><![CDATA[METHOD M_ConnectDisconnect
//////////////////
// Connect / Disconnect Load
//////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 
	

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// GTE Long Management
F_TRIG_GTELong(CLK:=A1_ProtectRelay.OUT_UminLong) ; // detect end of GTE long
RTRIG_ProtectEndEmergencyDisc(CLK := A1_GRID.MesDataExd.MesData.OUT_CmdEmergencyDisconnect); ///detect Emergency Disconnect
RTRIG_ProtectEndDisc(CLK := A1_GRID.MesDataExd.MesData.OUT_CmdDisconnect); //detect command disconnect

TP_GTELong(IN:=F_TRIG_GTELong.Q,PT:=ParamAlimAuxGTE);// AFTER GTE LONG := Lost of Autorisation feeding and stop production during 3 min. Enabled also after SUB_MV ReInit to allow closing of MainMVCB, after PLC restart.  
TPWaitToCloseMainMVCB(IN :=  RTRIG_ProtectEndEmergencyDisc.Q OR RTRIG_ProtectEndDisc.Q OR RTRIG_LimitationSofrel.Q, PT := T#90S); //TP to close mainmvcb after Emergency disconnect or decoupling to keep auxiliary

FTRIG_ProtectGTELong(CLK:= TP_GTELong.Q ) ; // disable cloding MainMVCB for 3 minutes after GTE long
FTRIG_CloseMainMVCB(CLK := TPWaitToCloseMainMVCB.Q); //closing mainmvcb after 10secondes after emergency stop or decoupling

TPCloseMainMVCB_EndGTELong(IN:=FTRIG_ProtectGTELong.Q, PT:=T#2S);		// 3 min after GTE long ended
TPCloseMainMVCBAfterDisconnect(IN:=FTRIG_CloseMainMVCB.Q, PT:=T#2S);

//MainMVCB

SR_CloseMainMVCBManual(SET1 := IN_CmdOpenMainMVCB,  RESET:= IN_CmdCloseMainMVCB OR IN_CmdReset_L ) ; // Inhibate the closing of MainMVCB after a manual opened commAND  A manual close command is then required. 

	// Open Command
	A1_MainMVCB.IN_CmdOpen :=  (IN_CmdOpenMainMVCB OR   A1_SUBMV.A1_ProtectRelay.MesDataExd.MesData.MesAlarmCom)AND NOT A1_PP.ParamForcedStayConnect;
	// Close Command
	A1_MainMVCB.IN_CmdClose := ((TPCloseMainMVCBAfterDisconnect.Q AND MesDataExd.MesData.MesOpened_AllFeederMVCB AND ParamAutoCloseMainMVCBEnabled ) OR ( TPCloseMainMVCB_EndGTELong.Q AND MesDataExd.MesData.MesOpened_AllFeederMVCB AND ParamAutoCloseMainMVCBEnabled) OR (IN_CmdCloseMainMVCB AND MesDataExd.MesData.MesOpened_AllFeederMVCB)) AND NOT SR_CloseMainMVCBManual.Q1;
	
//CELLULES DEPART
	//Equation logique ouverture du Départ FeederMVCB_1

CalFeederManualCmd := FALSE ; 
	FOR KK:= 1 TO CstNbFeederMVCB_G DO 
		SR_CloseManual_FeederMVCB[KK](SET1 := IN_CmdOpenFeederMVCB[KK],  RESET:= IN_CmdCloseFeederMVCB[kk] OR IN_CmdReset_L ) ; // Inhibate the closing of MainMVCB after a manual opened commAND  A manual close command is then required . 

		AX_FeederMVCB[KK].IN_CmdOpen := AX_FeederMVCB[KK].MesDataExd.MesData.MesClosed AND NOT AX_FeederMVCB[KK].MesDataExd.MesComutLocal AND (NOT A1_MainMVCB.MesDataExd.MesData.MesClosed OR IN_CmdOpenFeederMVCB[KK]);

		CalFeederManualCmd := CalFeederManualCmd OR IN_CmdCloseFeederMVCB[kk] OR IN_CmdOpenFeederMVCB[kk] ; 
	END_FOR

SUPER^.M_ConnectDisconnect() ; 

HVcellsMoving 	:= FALSE;

IF IN_CmdOpenMainMVCB OR IN_CmdCloseMainMVCB OR CalFeederManualCmd  THEN 
	IN_MesStopMVCC	:= TRUE ; 	// Stop Auto procedure if a manual action is done . 
END_IF

M_NoFeeding();	// decouplage : arret des onduleurs . 
M_Feeding();	// Couplage ]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Emulator" Id="{5eaae538-d1e6-40f2-be79-515bfece61bd}">
      <Declaration><![CDATA[METHOD M_Emulator
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
A1_MainMVCB.M_Emulator();

FOR KK:= 1 TO CstNbFeederMVCB_G DO 
	AX_FeederMVCB[KK].M_Emulator();
END_FOR	

// Simulation de l'ouverture de la cellule D2S par le relais de protection
A1_MainMVCB.IN_GTE_Default_Emul := A1_ProtectRelay.IN_MesAlarmUmin_IO;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_EquipmentCalls" Id="{cd14e27b-e38b-4832-8334-bb8855b280ad}">
      <Declaration><![CDATA[METHOD M_EquipmentCalls
//////////////////
// Evaluate AMS characteristics
//////////////////

VAR
	// Method local variables (reinitialized at each cycle) 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//MVR
	FOR KK:= 1 TO CstNbFeederMVCB_G DO 
		AX_FeederMVCB[KK].M_Execute() ; 			
	END_FOR 

	FOR KK:= 1 TO CstNbGridMVCB_G DO 
		AX_GridMVCB[KK].M_Execute() ; 			
	END_FOR 
	
A1_MainMVCB.M_Execute();	
A1_MeasureMVCB.M_Execute();
A1_AuxMVCB.M_Execute();

//CB BT			
A1_CB_48V.M_Execute();
A1_CB_230V.M_Execute();
A1_CB_24V.M_Execute();
A1_MainCB_LV.M_Execute();	
		
//Door Sensor
A1_DS_MV.M_Execute();			
A1_DS_LV.M_Execute();

//Motion sensor
//A1_MS.M_Execute();


//SEPAM
//A1_ProtectRelay.ConnectAuthorization := A1_GRID.OUT_GridConnAuthorConnWaitRec;
A1_ProtectRelay.M_Execute();

//Operation Meter	
A1_PM.M_Execute();
//A1_PM_Aux.M_Execute();

//DEIE
//A1_DEIE.IN_ConnectAuthorizationLost := A1_VDE_Sepam.C13100IO OR A1_VDE_Sepam.GteLong OR  A1_VDE_Sepam.GTE3Time OR UnknownFault;
A1_GRID.M_Execute() ; 	    

// UPS
A1_UPS_48v.M_Execute();

A1_UPS_24v.M_Execute();

// Door Sensor
A1_DS_LV.M_Execute();
A1_DS_MV.M_Execute();

// Smoke detector 
A1_SD_MV.M_Execute();

// ROUTEURS ADSL et 4G
A1_Router_ADSL.M_Execute();	 
A1_Router_4G.M_Execute();     
A1_IPC.M_Execute();            

// ES 
//A1_ES_MV.M_Execute() ; 			
//A1_ES_LV.M_Execute() ; 
A1_ES_Ext.M_Execute();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Evaluate" Id="{5a6afb5f-112a-4569-bef6-ff395a03de6a}">
      <Declaration><![CDATA[METHOD M_Evaluate
//////////////////
// Evaluate SUB.MV Data 
//////////////////
VAR 


END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ 
MesDataExd.MesData.MesU								:= 	A1_PM.MesDataExd.MesData.MesU;		
MesDataExd.MesData.MesFreq							:= 	A1_PM.MesDataExd.MesData.MesFreq;
MesDataExd.MesData.MesPsol							:= 	A1_PM.MesDataExd.MesData.MesP;
MesDataExd.MesData.MesQsol							:= 	A1_PM.MesDataExd.MesData.MesQ;
MesDataExd.MesData.MesPaux							:= 	A1_PM_Aux.MesDataExd.MesData.MesP ; 
MesDataExd.MesData.MesTanPhi						:= 	A1_PM.MesDataExd.MesData.MesTanPhi;

// Fire Detection in PTR => Open Feeder
// FOR KK:= 1 TO CstNbFeederMVCB_G DO 
// 	AX_FeederMVCB[KK].IN_FireDetection := AX_PTR[KK].A1_SD_INV.OUT_FireDetection OR AX_PTR[KK].A1_SD_Transfo.OUT_FireDetection   ;           			
// END_FOR
         	                            	                     
MesDataExd.MesData.MesOpened_AllFeederMVCB := TRUE;
MesDataExd.MesData.MesClosed_AllFeederMVCB := TRUE;
MesDataExd.MesData.MesClosed_ALOFeederMVCB := FALSE;
MesDataExd.MesData.MesOpened_ALOFeederMVCB := FALSE;

	FOR KK:= 1 TO CstNbFeederMVCB_G DO 
	MesDataExd.MesData.MesOpened_AllFeederMVCB		:=  AX_FeederMVCB[KK].MesDataExd.MesData.MesOpened  AND MesDataExd.MesData.MesOpened_AllFeederMVCB; 	 		// All MV Deptarture are Opened
	MesDataExd.MesData.MesClosed_AllFeederMVCB		:=  AX_FeederMVCB[KK].MesDataExd.MesData.MesClosed AND MesDataExd.MesData.MesClosed_AllFeederMVCB; 		// All MV Deptarture are Closed	                            	
	MesDataExd.MesData.MesOpened_ALOFeederMVCB		:=  AX_FeederMVCB[KK].MesDataExd.MesData.MesOpened OR MesDataExd.MesData.MesOpened_ALOFeederMVCB;		  	// All Of MV Deptarture are Opened
	MesDataExd.MesData.MesClosed_ALOFeederMVCB		:=  AX_FeederMVCB[KK].MesDataExd.MesData.MesClosed OR MesDataExd.MesData.MesClosed_ALOFeederMVCB; 			// All Of MV Deptarture are Closed	                       			
	END_FOR

//MesDataExd.SD_LV				:= A1_SD_LV.MesDataExd		;
MesDataExd.Transfo_Aux		:= A1_Transfo_Aux.MesDataExd; 

// GRID
	A1_ProtectRelay.IN_CmdReset_3GTEFault 		:= A1_GRID.IN_CmdAutCpl_IO OR A1_GRID.IN_CmdAutCpl_other;

	A1_GRID.IN_PP_Connected						:= SEL(A1_PP.MesState.2 = 1, FALSE, TRUE); //A1_PP.MesState.2 = 1; // A1_PP.MesState= 0 ; //Modif LWN : CalState.1     //Centrale couplée si True, Sinon decouplée GO TO M_StateManager
	A1_GRID.IN_ConnectAuthorizationLost 		:= A1_ProtectRelay.IN_MesAlarmIMax_IO OR A1_ProtectRelay.MesDataExd.MesData.MesAlarmUmin_Long OR  A1_ProtectRelay.MesDataExd.MesData.MesAlarm_GTE3Time;
	A1_GRID.IN_Unavailable						:= A1_MainMVCB.MesDataExd.MesComutLocal OR A1_ES_Ext.MesDataExd.MesData.MesAlarmState (*OR A1_ES_LV.MesDataExd.MesData.MesAlarmState OR A1_ES_MV.MesDataExd.MesData.MesAlarmState*);
	A1_MainMVCB.IN_MesTripped_IO				:= A1_ProtectRelay.IN_MesAlarmIMax_IO;

	TP_UnknownFault(PT:=ParamTempoUnknowFault);	
	
// SUBMV DataExd
	//MesDataExd				:= MesDataExd.MesData. 
                                	
	MesDataExd.CB_24V						:= A1_CB_24V.MesDataExd;
	MesDataExd.CB_48V						:= A1_CB_48V.MesDataExd; 
	MesDataExd.CB_230V						:= A1_CB_230V.MesDataExd;
	MesDataExd.MainCB_LV					:= A1_MainCB_LV.MesDataExd;	
	MesDataExd.SD_MV						:= A1_SD_MV.MesDataExd;	
	MesDataExd.DS_MV						:= A1_DS_MV.MesDataExd; 		
	MesDataExd.DS_LV						:= A1_DS_LV.MesDataExd;
	MesDataExd.MeasureMVCB					:= A1_MeasureMVCB.MesDataExd; 		
	MesDataExd.AuxMVCB						:= A1_AuxMVCB.MesDataExd; 
	MesDataExd.MainMVCB						:= A1_MainMVCB.MesDataExd; 
	MesDataExd.ProtectRelay					:= A1_ProtectRelay.MesDataExd;	
	MesDataExd.PM							:= A1_PM.MesDataExd;
	MesDataExd.PM_Aux						:= A1_PM_Aux.MesDataExd;	
	MesDataExd.UPS_48v						:= A1_UPS_48v.MesDataExd;
	MesDataExd.UPS_24v						:= A1_UPS_24v.MesDataExd;
	MesDataExd.Router_ADSL					:= A1_Router_ADSL.MesDataExd;
	MesDataExd.Router_4G					:= A1_Router_4G.MesDataExd;
	MesDataExd.IPC 							:= A1_IPC.MesDataExd;		
	MesDataExd.GRID							:= A1_GRID.MesDataExd;
										
	FOR KK:= 1 TO CstNbFeederMVCB_G DO 
		MesDataExd.AX_FeederMVCB[KK]		:=  AX_FeederMVCB[KK].MesDataExd; 	
	END_FOR	
	
	FOR KK:= 1 TO CstNbGridMVCB_G DO 
		MesDataExd.AX_GridMVCB[KK]			:=  AX_GridMVCB[KK].MesDataExd;	
	END_FOR	

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Feeding" Id="{2f590dd8-6d8f-4c75-8e53-8d85d3769ff2}">
      <Declaration><![CDATA[METHOD M_Feeding
VAR
	CP_Temp	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Sequence couplage

//Tempo de sécurité: ouverture de tous les départ transfor avant fermeture MainMVCB
TP_Feed_TR_Open(IN:=IN_CmdFeeding,PT:=T#2S);

R_TRIG_Feeding(CLK:= IN_CmdFeeding) ; 
IF R_TRIG_Feeding.Q OR IN_CmdReset_L OR MesDataExd.MesData.MesClosed_AllFeederMVCB  THEN
	//On remet a Zero SSi il s'agit d'une nouvelle demande ou d'une demande de reset ou bien que toutes les cellules sonty fermée
	CompletedFeed := 0;
	CompletedFeedAlarm := 0 ;
	HVcellsMoving	:= FALSE; // CC HV Cells
END_IF
 
RSFeed(SET :=IN_CmdFeeding , RESET1:=IN_MesStopMVCC OR CompletedFeed>0 OR MesDataExd.MesData.MesClosed_AllFeederMVCB OR NOT A1_SUBMV.A1_GRID.MesDataExd.MesData.OUT_CmdAutCpl) ; 

// Déroulement de la séquence 
IF (RSFeed.Q1) THEN
	
	//1 - INIT && TEMPO
		CompletedFeed := 0;
		
		HVcellsMoving	:= TRUE; // HV Cells are moving
		//Condition pour lancement de la tempo de sécurité : Au moins un départ est resté ouvert
		TON_FeedTR(IN:= A1_MainMVCB.MesDataExd.MesData.MesClosed AND MesDataExd.MesData.MesOpened_ALOFeederMVCB AND A1_GRID.MesDataExd.MesData.OUT_CmdAutCpl  , PT:=ParamTimeOutConnect - T#1S);
		//Tempo de sécurité : MainMVCB restée ouverte
		TON_FeedMainMVCB(IN:=  A1_MainMVCB.MesDataExd.MesData.MesOpened AND NOT SR_CloseMainMVCBManual.Q1, PT:= ParamTimeOutConnect - T#1S);

	//2 - Verification que toutes les cellules départs soient ouvertes avant fermeture MainMVCB .

		IF TP_Feed_TR_Open.Q AND A1_MainMVCB.MesDataExd.MesData.MesOpened THEN
			FOR KK:= 1 TO CstNbFeederMVCB_G DO 	
				AX_FeederMVCB[KK].IN_CmdOpen := AX_FeederMVCB[KK].Mesclosed AND NOT AX_FeederMVCB[KK].MesDataExd.MesComutLocal;
			END_FOR 	
		END_IF
	
	//3 - Fermeture de la MainMVCB
	
		// Temporise le retour à la commande distante. 
		
		TON_ComutDistant(IN:= NOT A1_MainMVCB.MesDataExd.MesComutLocal , PT:=T#5S) ; 
	
		A1_MainMVCB.IN_CmdClose 	:= (A1_MainMVCB.MesDataExd.MesData.MesOpened AND TON_ComutDistant.Q AND MesDataExd.MesData.MesOpened_AllFeederMVCB AND NOT TP_Feed_TR_Open.Q AND ( ParamAutoCloseMainMVCBEnabled OR A1_GRID.MesDataExd.MesData.OUT_CmdAutCpl)) AND NOT SR_CloseMainMVCBManual.Q1; //Je laisse une tempo de 2sec avant couplage
	
	//4 - Fermeture des Feeders 
	
		TON_FeedStep[1](IN:= A1_MainMVCB.MesDataExd.MesData.MesClosed,PT:=ParamTempoPoste);
			
		IF A1_GRID.MesDataExd.MesData.OUT_CmdAutCpl  THEN 
			
			FOR KK:= 1 TO CstNbFeederMVCB_G DO 
				//Fermeture du Départ D : Sur fermeture de la MainMVCB
				AX_FeederMVCB[KK].IN_CmdClose := AX_FeederMVCB[KK].MesDataExd.MesData.MesOpened AND TON_FeedStep[KK].Q AND NOT AX_FeederMVCB[KK].MesDataExd.MesComutLocal AND NOT SR_CloseManual_FeederMVCB[KK].Q1;
				(*Lancement tempo sur fermeture Depart D et etat du commutateur sur remote*)
				TON_FeedStep[KK+1](IN:=TON_FeedStep[KK].Q   ,PT:=ParamTempoPoste);
			END_FOR

		ELSE
			FOR KK:= 2 TO CstNbFeederMVCB_G DO 
				TON_FeedStep[KK](IN:=FALSE);
			END_FOR 
		END_IF
		
	//Gestion du CompleteFeed - Etat de fermeture des cellules du PDL
	
		//Action Terminé sans erreur : MainMVCB et tous depart sont fermés
			CompletedFeed.0 := A1_MainMVCB.MesDataExd.MesData.MesClosed  AND MesDataExd.MesData.MesClosed_AllFeederMVCB;
				
		//Action terminé avec erreur : MainMVCB restée ouverte
			CompletedFeed.1 := TON_FeedMainMVCB.Q; 
		
		//Action terminé avec warning : Au moins un depart est resté ouvert
			CompletedFeed.2 := TON_FeedTR.Q  ; 
			
			//Refermeture des ESS en cas de recouplage
				IF CompletedFeed.2 THEN
				
					OUT_ESS_CouplingSequence := TRUE;
					OUT_PTR_CouplingSequence := TRUE;
				
				END_IF
				
	//Sauvegarde de l'action pour alarmes
	
		CompletedFeedAlarm.0 := CompletedFeed.0;
		CompletedFeedAlarm.1 := CompletedFeed.1;
		CompletedFeedAlarm.2 := CompletedFeed.2;
		
ELSE
	
	//Reinitilisation pour Front montant
	IN_CmdFeeding 		:= FALSE;
	
	FOR KK:= 1 TO CstNbFeederMVCB_G DO 
		TON_FeedStep[KK](IN:=FALSE);
	END_FOR 

	TON_FeedMainMVCB(IN:=FALSE);
	TON_FeedTR(IN:=FALSE);
	TP_Feed_TR_Open(IN:=FALSE);
	HVcellsMoving 	:= FALSE;
	
	OUT_ESS_CouplingSequence := FALSE;
	OUT_PTR_CouplingSequence := FALSE;
	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{9fd731cf-1739-4e13-948c-42568fc961ce}">
      <Declaration><![CDATA[METHOD M_Init


VAR

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
A1_GRID.ParamRseAvailable	:=TRUE	  ; 	
A1_GRID.ParamTaAvailable	:=TRUE	  ;   
A1_GRID.ParamP0Available	:=TRUE	  ;  
A1_GRID.ParamQ0Available	:=TRUE	  ; 
A1_GRID.ParamTONFiltering	:=T#200MS ;
A1_GRID.ParamPmaxPark		:= 15000  ;    
A1_GRID.ParamQMax			:= 3000   ;    
A1_GRID.ParamQMin			:= -3000  ;    
A1_GRID.ParamPMin			:= 0      ;    

// Cells 
A1_MainMVCB.ParamClosedInput_Connected := FALSE ; 
A1_MainMVCB.ParamNC := TRUE ;
A1_MainMVCB.ParamAlarmPwr_NC := FALSE ;
A1_MainMVCB.ParamNbFdbck := 1 ; 
A1_MainMVCB.ParamSectLigne := 1 ; 
A1_MainMVCB.ParamTP_Impulsion := T#2S ; 
A1_MainMVCB.ParamTimeOut_Alarm := T#500MS ; 
A1_MainMVCB.ParamTimeOut_Close := T#1S ; 
A1_MainMVCB.ParamTimeOut_Open := T#1S ;
A1_MainMVCB.ParamComutNc := TRUE;
 	
// FeederMVCB_ 
FOR KK:= 1 TO CstNbPTR_G DO 
	
	AX_FeederMVCB[KK].ParamClosedInput_Connected := TRUE ; 
	AX_FeederMVCB[KK].ParamNC := FALSE ; 
	AX_FeederMVCB[KK].ParamNbFdbck := 1 ; 
	AX_FeederMVCB[KK].ParamSectLigne := 1 ; 
	AX_FeederMVCB[KK].ParamTP_Impulsion := T#2S ; 
	AX_FeederMVCB[KK].ParamTimeOut_Alarm := T#500MS ; 
	AX_FeederMVCB[KK].ParamTimeOut_Close := T#1S ; 
	AX_FeederMVCB[KK].ParamTimeOut_Open := T#1S ;
	AX_FeederMVCB[KK].A1_Sect.ParamNC := TRUE;
	
END_FOR

FOR KK:= 1 TO CstNbGridMVCB_G DO 
	
	AX_GridMVCB[KK].ParamClosedInput_Connected := TRUE ; 
	AX_GridMVCB[KK].ParamNC := FALSE ; 
	AX_GridMVCB[KK].ParamNbFdbck := 1 ; 
	AX_GridMVCB[KK].ParamTimeOut_Alarm := T#500MS ; 
	AX_GridMVCB[KK].ParamTimeOut_Close := T#1S ; 
	AX_GridMVCB[KK].ParamTimeOut_Open := T#1S ; 	
	
END_FOR

A1_MeasureMVCB.ParamClosedInput_Connected := TRUE ; 
A1_MeasureMVCB.ParamFuseNC := FALSE ; 
A1_MeasureMVCB.ParamNC := FALSE ; 
A1_MeasureMVCB.ParamNbFdbck := 1 ; 
A1_MeasureMVCB.ParamTP_Impulsion := T#2S ; 
A1_MeasureMVCB.ParamTimeOut_Alarm := T#500MS ; 
A1_MeasureMVCB.ParamTimeOut_Close := T#1S ; 
A1_MeasureMVCB.ParamTimeOut_Open := T#1S ;
	
A1_AuxMVCB.ParamClosedInput_Connected := FALSE ; 
A1_AuxMVCB.ParamFuseNC := TRUE ; 
A1_AuxMVCB.ParamNC := FALSE ; 
A1_AuxMVCB.ParamNbFdbck := 1 ; 
A1_AuxMVCB.ParamTP_Impulsion := T#2S ; 
A1_AuxMVCB.ParamTimeOut_Alarm := T#500MS ; 
A1_AuxMVCB.ParamTimeOut_Close := T#1S ; 
A1_AuxMVCB.ParamTimeOut_Open := T#1S ;

//A1_CB_230V.ParamAtleastOne := TRUE ; 
//A1_CB_230V.ParamNbSensors := 1 ; 
//A1_CB_230V.ParamCableCutSecurity := FALSE ;
//A1_CB_230V.ParamNC_Tripped := TRUE;
//
//A1_CB_230V_Prio.ParamAtleastOne := TRUE ; 
//A1_CB_230V_Prio.ParamNbSensors := 1 ; 
//A1_CB_230V_Prio.ParamCableCutSecurity := FALSE ;
//A1_CB_230V_Prio.ParamNC_Tripped := TRUE;

//A1_DS.ParamAtleastOne := TRUE ; 
//A1_DS.ParamNbSensors := 1 ; 
//A1_DS.ParamCableCutSecurity := FALSE ; 	
//A1_DS.ParamTempoDoorAlarm := T#15S ; 
//
//A1_MainCB_Aux.ParamAtleastOne := TRUE ; 
//A1_MainCB_Aux.ParamNbSensors := 1 ; 
//A1_MainCB_Aux.ParamCableCutSecurity := FALSE ;
//A1_MainCB_Aux.ParamNC_Tripped := TRUE;
//
//A1_SPD_Aux.ParamAtleastOne := TRUE ; 
//A1_SPD_Aux.ParamNbSensors := 1 ; 
//A1_SPD_Aux.ParamCableCutSecurity := TRUE ; 	
//
//A1_SD_LV.ParamAtleastOne := TRUE ; 
//A1_SD_LV.ParamNbSensors := 1 ; 
//A1_SD_LV.ParamCableCutSecurity := TRUE ; 	
		
A1_SD_MV.ParamAtleastOne := TRUE ; 
A1_SD_MV.ParamNbSensors := 1 ; 
A1_SD_MV.ParamCableCutSecurity := TRUE ; 	
	
//A1_ES.ParamAtleastOne := TRUE ;
//A1_ES.ParamNbSensors := 1 ; 
//A1_ES.ParamCableCutSecurity := FALSE ; 
//A1_ES.ParamTempoEs := T#5S ;
//		
//A1_ProtectRelay.ParamClockReadTime := T#2S ; 
//A1_ProtectRelay.ParamTimeOut	:= T#5S ; 
//A1_ProtectRelay.ParamUnitID := 1 ; 
//A1_ProtectRelay.ParamAlarmUmin_NC:= FALSE;
//A1_ProtectRelay.ParamAlarmImax_NC:= FALSE;
//A1_ProtectRelay.ParamWatchdog_NC:= FALSE;

A1_PM.ParamClockReadTime := T#200MS ; 
A1_PM.ParamIPAddress := '10.0.3.30' ; 
A1_PM.ParamTempoComAlarm := T#10S ;
A1_PM.ParamTimeout := T#2S ; 
A1_PM.ParamUnitID := 5 ; 

A1_PM_Aux.ParamClockReadTime := T#200MS ; 
A1_PM_Aux.ParamIPAddress := '10.0.3.30' ; 
A1_PM_Aux.ParamTempoComAlarm := T#10S ;
A1_PM_Aux.ParamTimeout := T#2S ; 
A1_PM_Aux.ParamUnitID := 5 ; 

A1_UPS_24v.ParamClockReadTime := T#5S ; 
A1_UPS_24v.ParamTempoComAlarm := T#20S; 
A1_UPS_24v.ParamTempoComWarning:= T#10S ; 
A1_UPS_24v.ParamTimeOut	:= T#10S ; 
A1_UPS_24v.ParamNC	:= FALSE ; 
			
A1_UPS_48v.ParamClockReadTime := T#5S ; 
A1_UPS_48v.ParamTempoComAlarm := T#20S; 
A1_UPS_48v.ParamTempoComWarning:= T#10S ; 
A1_UPS_48v.ParamTimeOut	:= T#10S ; 
A1_UPS_48v.ParamNC	:= FALSE ; 

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_NoFeeding" Id="{97d60399-a7a5-4de4-8666-44c1ea28473d}">
      <Declaration><![CDATA[METHOD M_NoFeeding
VAR

	
	


END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Sequence decouplage

RSNoFeed(SET :=IN_CmdNoFeeding , RESET1:= IN_MesStopMVCC OR CompletedNoFeed >0 ) ; 

IF (RSNoFeed.Q1) THEN
//INIT && Tempo
	CompletedNoFeed := 0;
	HVcellsMoving := TRUE;
	
	//Tempo de sécurité : La centrale est toujours connectée
	TON_NoFeedTR(IN:= A1_PP.MesState.2 , PT:=ParamTimeOutDisconnect- T#10S);
	
	//Tempo de sécurité : MainMVCB ouverte
	TON_NoFeedMainMVCB(IN:= A1_MainMVCB.MesDataExd.MesData.MesClosed , PT:=ParamTimeOutDisconnect- T#1S);
	
	// Ouverture des cellules 
	A1_MainMVCB.IN_CmdOpen := TON_NoFeedTR.Q ; // Open MainMVCB if the power plant is still coupled after the alarm time  /

	// CompletedNoFeed - Gestion des différents états
	
		//Action terminée sans erreur : La centrale est decouplée ou effacée ( ess a l arret ) 
			CompletedNoFeed.0 	:=  A1_PP.MesState.0 ; 
			
			CompletedNoFeed.1 	:=  MesState.2 ; // La centrale est decouplée
			
		//Action terminé avec erreur : MainMVCB restée fermée 
			CompletedNoFeed.2 :=  TON_NoFeedMainMVCB.Q; // 	
			CompletedNoFeed.3 	:=   MesState.0  ; // la centrale est effacée .  		
		
	//KEEP LAST ALARMS
	CompletedNoFeedAlarm.0 := MesState.2  ; ;	// La centrale est découplée ( stopped , but MainMVCB closed) 
	CompletedNoFeedAlarm.1 := TON_NoFeedMainMVCB.Q ;	// echec de l'étape 2 , ouverture de la MainMVCB . 
	CompletedNoFeedAlarm.2 := TON_NoFeedTR.Q;	// Echec de l'étape 1 , ouverture des Imbess
	CompletedNoFeedAlarm.4 := MesState.0  ; ;	// La centrale est effacée	( MainMVCB is opened ) 
	
ELSE 
	IN_CmdNoFeeding 	:= FALSE;
	TON_NoFeedTR (IN:=FALSE);
	TON_NoFeedMainMVCB(IN:=FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StateManager" Id="{711e5be2-c596-4a7a-b4df-bf3895fb76ac}">
      <Declaration><![CDATA[METHOD M_StateManager
//////////////////
// Manages SUB_MV state . 
//////////////////
VAR 
	// Method local variables (reinitialized at each cycle) 
	

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// STATIC STATE //
//  bit 0 : MainMVCB ouverte  , bit 1 , MainMVCB fermée , bit 2 , MainMVCB fermée , certaines cellules ouverters
	MesState :=0 ;

	IF A1_MainMVCB.MesDataExd.MesData.MesClosed  THEN
		IF MesDataExd.MesData.MesClosed_ALOFeederMVCB THEN		
			MesState.1 := 1 ; // Centrale couplé 
		ELSE 
			MesState.2 := 1 ; //Centrale découplée
		END_IF
	ELSE
		MesState.0 := 1; //Centrale effacée
	END_IF
	
MesDataExd.MesData.MesState :=  MesState;

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SUBMV">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_AlarmManagement">
      <LineId Id="1888" Count="2" />
      <LineId Id="1911" Count="5" />
      <LineId Id="2046" Count="0" />
      <LineId Id="2045" Count="0" />
      <LineId Id="2047" Count="0" />
      <LineId Id="1917" Count="89" />
      <LineId Id="2065" Count="0" />
      <LineId Id="2007" Count="5" />
      <LineId Id="2083" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_ConnectDisconnect">
      <LineId Id="435" Count="0" />
      <LineId Id="347" Count="0" />
      <LineId Id="423" Count="2" />
      <LineId Id="351" Count="1" />
      <LineId Id="426" Count="0" />
      <LineId Id="356" Count="2" />
      <LineId Id="428" Count="0" />
      <LineId Id="359" Count="1" />
      <LineId Id="363" Count="3" />
      <LineId Id="368" Count="0" />
      <LineId Id="431" Count="3" />
      <LineId Id="374" Count="8" />
      <LineId Id="384" Count="2" />
      <LineId Id="397" Count="1" />
      <LineId Id="436" Count="0" />
      <LineId Id="399" Count="0" />
      <LineId Id="402" Count="2" />
      <LineId Id="406" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_Emulator">
      <LineId Id="1" Count="8" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_EquipmentCalls">
      <LineId Id="376" Count="0" />
      <LineId Id="439" Count="1" />
      <LineId Id="378" Count="0" />
      <LineId Id="474" Count="2" />
      <LineId Id="473" Count="0" />
      <LineId Id="477" Count="0" />
      <LineId Id="379" Count="0" />
      <LineId Id="381" Count="1" />
      <LineId Id="384" Count="4" />
      <LineId Id="391" Count="4" />
      <LineId Id="487" Count="1" />
      <LineId Id="396" Count="3" />
      <LineId Id="441" Count="0" />
      <LineId Id="401" Count="4" />
      <LineId Id="464" Count="0" />
      <LineId Id="406" Count="4" />
      <LineId Id="412" Count="8" />
      <LineId Id="424" Count="0" />
      <LineId Id="426" Count="1" />
      <LineId Id="170" Count="0" />
      <LineId Id="454" Count="1" />
      <LineId Id="443" Count="0" />
      <LineId Id="442" Count="0" />
      <LineId Id="445" Count="0" />
      <LineId Id="444" Count="0" />
      <LineId Id="486" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_Evaluate">
      <LineId Id="2282" Count="6" />
      <LineId Id="2410" Count="3" />
      <LineId Id="2409" Count="0" />
      <LineId Id="2289" Count="11" />
      <LineId Id="2307" Count="0" />
      <LineId Id="2401" Count="0" />
      <LineId Id="2309" Count="0" />
      <LineId Id="2321" Count="12" />
      <LineId Id="2381" Count="0" />
      <LineId Id="2334" Count="3" />
      <LineId Id="2341" Count="0" />
      <LineId Id="2344" Count="1" />
      <LineId Id="2348" Count="2" />
      <LineId Id="2372" Count="7" />
      <LineId Id="2351" Count="0" />
      <LineId Id="2380" Count="0" />
      <LineId Id="2352" Count="3" />
      <LineId Id="2392" Count="1" />
      <LineId Id="2391" Count="0" />
      <LineId Id="2364" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_Feeding">
      <LineId Id="402" Count="3" />
      <LineId Id="407" Count="7" />
      <LineId Id="506" Count="0" />
      <LineId Id="417" Count="0" />
      <LineId Id="505" Count="0" />
      <LineId Id="418" Count="2" />
      <LineId Id="497" Count="0" />
      <LineId Id="549" Count="0" />
      <LineId Id="555" Count="0" />
      <LineId Id="421" Count="0" />
      <LineId Id="423" Count="3" />
      <LineId Id="429" Count="5" />
      <LineId Id="532" Count="0" />
      <LineId Id="547" Count="0" />
      <LineId Id="440" Count="0" />
      <LineId Id="442" Count="0" />
      <LineId Id="550" Count="2" />
      <LineId Id="443" Count="0" />
      <LineId Id="537" Count="0" />
      <LineId Id="539" Count="0" />
      <LineId Id="450" Count="0" />
      <LineId Id="498" Count="0" />
      <LineId Id="500" Count="0" />
      <LineId Id="499" Count="0" />
      <LineId Id="451" Count="0" />
      <LineId Id="453" Count="6" />
      <LineId Id="461" Count="0" />
      <LineId Id="463" Count="6" />
      <LineId Id="543" Count="1" />
      <LineId Id="470" Count="1" />
      <LineId Id="540" Count="1" />
      <LineId Id="508" Count="0" />
      <LineId Id="542" Count="0" />
      <LineId Id="472" Count="1" />
      <LineId Id="520" Count="0" />
      <LineId Id="522" Count="6" />
      <LineId Id="521" Count="0" />
      <LineId Id="477" Count="0" />
      <LineId Id="546" Count="0" />
      <LineId Id="478" Count="0" />
      <LineId Id="554" Count="0" />
      <LineId Id="479" Count="2" />
      <LineId Id="545" Count="0" />
      <LineId Id="482" Count="1" />
      <LineId Id="553" Count="0" />
      <LineId Id="484" Count="7" />
      <LineId Id="529" Count="1" />
      <LineId Id="519" Count="0" />
      <LineId Id="531" Count="0" />
      <LineId Id="492" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_Init">
      <LineId Id="375" Count="37" />
      <LineId Id="414" Count="0" />
      <LineId Id="509" Count="0" />
      <LineId Id="415" Count="5" />
      <LineId Id="510" Count="1" />
      <LineId Id="422" Count="86" />
      <LineId Id="105" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_NoFeeding">
      <LineId Id="190" Count="1" />
      <LineId Id="199" Count="0" />
      <LineId Id="201" Count="4" />
      <LineId Id="244" Count="0" />
      <LineId Id="206" Count="1" />
      <LineId Id="245" Count="0" />
      <LineId Id="208" Count="3" />
      <LineId Id="218" Count="0" />
      <LineId Id="221" Count="1" />
      <LineId Id="249" Count="0" />
      <LineId Id="223" Count="3" />
      <LineId Id="248" Count="0" />
      <LineId Id="227" Count="3" />
      <LineId Id="232" Count="1" />
      <LineId Id="235" Count="0" />
      <LineId Id="246" Count="0" />
      <LineId Id="236" Count="0" />
      <LineId Id="247" Count="0" />
      <LineId Id="237" Count="1" />
      <LineId Id="240" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SUBMV.M_StateManager">
      <LineId Id="57" Count="5" />
      <LineId Id="64" Count="1" />
      <LineId Id="67" Count="2" />
      <LineId Id="71" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>